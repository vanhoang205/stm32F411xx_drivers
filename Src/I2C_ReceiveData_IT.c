/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f411xx.h"
#include "drv_gpio.h"
#include "drv_i2c.h"

#define MY_ADDR 0x61;
#define SLAVE_ADDR  0x68

uint8_t buffer[32] = {1,2,3,4,5,4};

GPIO_Handle_t button;
GPIO_Handle_t i2cPin;
I2C_Handle_t i2c1;

uint8_t cmd1 = 0x51;
uint8_t cmd2 = 0x52;
uint8_t lendata;
volatile uint8_t rxComplt;

extern void initialise_monitor_handles(void);

void delay() {
	for (int i = 0; i < 500000 / 2; i++)
		;
}

void InitButton() {

	// Initialize configure GPIO for Button -  PA
	button.pGPIO = GPIOA;
	button.pinConfig.pinMode = GPIO_PINMODE_INPUT;
	button.pinConfig.outType = GPIO_OUTTYPE_PUPU;
	button.pinConfig.outSpeed = GPIO_OUTSPEED_HIGH;
	button.pinConfig.resPull = GPIO_RESPULL_NONE;
	button.pinConfig.altFunc = GPIO_ALTFUNC_0;
	button.pinConfig.pinNum = GPIO_PINNUM_0;

	GPIO_Init(&button);

}
void InitInterface_I2C1() {

	// Initialize Alternative pin for I2C Peripheral
	i2cPin.pGPIO = GPIOB;
	i2cPin.pinConfig.pinMode = GPIO_PINMODE_ALT;
	i2cPin.pinConfig.outType = GPIO_OUTTYPE_OD;
	i2cPin.pinConfig.outSpeed = GPIO_OUTSPEED_HIGH;
	i2cPin.pinConfig.resPull = GPIO_RESPULL_NONE;
	i2cPin.pinConfig.altFunc = GPIO_ALTFUNC_4;

	// Initialize SCL pin for I2C peripheral
	i2cPin.pinConfig.pinNum = GPIO_PINNUM_8;
	GPIO_Init(&i2cPin);

	// Initialize SDA pin for I2C peripheral
	i2cPin.pinConfig.pinNum = GPIO_PINNUM_9;
	GPIO_Init(&i2cPin);

	// Configure I2C parameters
	i2c1.pI2C = I2C1;
	i2c1.config.ACKControl = I2C_ACKCONTROL_ENABLE;
	i2c1.config.deviceAddress = MY_ADDR;
	i2c1.config.dutyCycleFM = I2C_DUTYCYCLEFM_2;
	i2c1.config.sclSpeed = I2C_SCLSPEED_SM;
	//i2c1.currentStatus = I2C_STATUS_READY;
	I2C_Init(&i2c1);

}

int main(void) {
	initialise_monitor_handles();

	InitButton();
	InitInterface_I2C1();
	//I2C IRQ configurations
	I2C_EnableIRQ(IRQ_NO_I2C1_EV, TRUE);
	I2C_EnableIRQ(IRQ_NO_I2C1_ER, TRUE);

	while (1) {
		if (GPIO_ReadPin(GPIOA, GPIO_PINNUM_0)) {
			delay();

			while (I2C_MasterTransmitIT(&i2c1, SLAVE_ADDR, &cmd1, 1, TRUE)
					!= I2C_STATUS_READY);

			while (I2C_MasterReceiveIT(&i2c1, SLAVE_ADDR, &lendata, 1, TRUE)
					!= I2C_STATUS_READY)
				;
			rxComplt = RESET;
			while (I2C_MasterTransmitIT(&i2c1, SLAVE_ADDR, &cmd2, 1, TRUE)
					!= I2C_STATUS_READY)
				;
			while (I2C_MasterReceiveIT(&i2c1, SLAVE_ADDR, buffer, lendata,
					FALSE) != I2C_STATUS_READY)
				;

			while (rxComplt != SET);
			buffer[lendata + 1] = '\0';
			printf("Data: %s", buffer);
		}
	}
}

void I2C1_EV_IRQHandler(void) {
	I2C_EV_IRQHandling(&i2c1);
}

void I2C1_ER_IRQHandler (void)
{
	I2C_ER_IRQHandling(&i2c1);
}

void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t flagEvent) {
	if (flagEvent == I2C_EV_DATA_TX_CMPLT) {
		printf("Tx is complete \n");
	} else if (flagEvent == I2C_EV_DATA_RX_CMPLT) {
		printf("Rx is complete \n");
		rxComplt = TRUE;
	} else if (flagEvent == I2C_ER_AF) {
		printf("Error: Ack failure\n");
		while(1);
	}
}
